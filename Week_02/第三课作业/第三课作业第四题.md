**第三课作业第四题**

**题目：根据上述自己对于第一题和第二题的演示，写一段对于不同GC的总结，提交到github。**

**SerialGC**

​	    串行垃圾收集器，单线程收集垃圾，进行垃圾收集的时候会STW，适用于单核CPU且内存较小的情况。常见的组合是新生代使用SerialGC，采用复制清除算法，老年代采用SerialOldGC, 采用标记整理算法，同时SerialOldGC是CMS垃圾收集器的备选收集器。

**ParallelGC**

​	    并行垃圾收集器，GC时可以多个线程同时进行，进行了垃圾收集的时候会STW， 和SerialGC的区别就在于使用多个线程同时GC，适用于多核CPU以及对系统吞吐量要求较高的场景。因为ParallelGC实现简单，收集高效，因此从全局看，在多核环境下，其系统吞吐量是相对最高的，但是当堆内存较大的时候， 其单次的GC停顿时间可能会很长，因此一些对响应时间要求较高的系统， 不适合使用ParallelGC，一般的普通web应用， 系统要求一两百ms返回，堆内存在2-4个G，用ParallelGC是完全没问题的。

​	    ParallelGC新生代有两款，ParNewGC和ParScanvengeGC，两者都采用复制清除算法，区别在于ParScanvengeGC是吞吐量优先的收集器，而ParNewGC则常和CMSGC搭配使用。老年代则使用ParallelOldGC， 采用标记整理算法， 是JDK8默认的垃圾收集器。

**CMSGC**

​		并发垃圾收集器，是老年代的垃圾收集器，采用标记清理算法，一般和ParNewGC搭配使用，是一款注重停顿时间的垃圾收集器，它的核心思想是将GC的流程进一步细分， 将一些步骤和用户线程同时执行，以此达到降低停顿的目的。

​		CMS的GC流程：

​			初始标记： 会STW，标记ROOTs直达的对象。

​			并发标记：和用户线程一起执行，从上一步标记的对象出发，标记整个堆中的对象。

​			并发预清理：针对在并发标记阶段出现的对象引用改变的情况，用脏卡进行标记。

​			最终标记：会STW，确定最终的对象引用状态

​			并发清除：清理对象

​			并发重置：进行一些下次收集前的准备工作

​	CMS的优点是停顿时间短， 存在的问题一是标记清理会产生内存碎片， 二是在极端情况下可能会退化为串行GC，因为在老年代GC的过程中，由于用户线程还在运行， 还会创建对象，因此可能还会伴随几次新生代的GC，也有可能会有对象达到升代年龄， 晋升到老年代，如果此时老年代的内存不够用，那么JVM使用SerialGC进行FULLGC，因此，为了避免该情况发生， 可以适当调低CMS的并发收集阈值，让并发收集早一些进行，确保老年代当中有足够的内存空间。

**G1GC**

​	G1GC，是一款新老年代通吃的垃圾收集器，其特点是还有分代的概念， 但是代际之间并不是严格限定死的， 而是在运行过程中弹性伸缩，G1也是一款注重响应时间的垃圾收集器，JDK9以后G1是默认的GC， 其在大内存情况下能够将GC停顿时间降低很多，因此适用于大的堆内存（一般6G到十几个G之间）。G1将整个堆空间划分为一个个固定大小的Region（Region的大小为2的整数次幂，默认是1M），每个Region既可能是新生代， 也可能是老年代，此外，G1中还有H区的概念， 即保存一个Region存不下的大对象区域。

​	G1由于将内存划分为一个个Region，因此GC时并不需要回收整个堆空间，G1会维护一个各个区域中垃圾的比例表，通过该表，G1只需要对部分垃圾比例最高的Region进行回收即可，因此能够做到垃圾回收性价比最高。

​	G1GC的流程和CMS类似， 也是包括初始标记，并发标记，并发预清理，最终标记，并发清除和重置几个步骤。

​	使用G1GC，一般不要直接设定死新生代的大小， 而是设定一个最大停顿时间， G1会根据设定的目标动态的调整整个堆中新老生代的区域数量， 以达到满足GC停顿时间的要求



**各类GC的常用调优参数：**

​		对于所有的GC：

​		第一都要设置最大堆内存大小，并且为了JVM频繁扩容影响性能，同时也会同时设置初始堆内存大小， 即-Xmx和-Xms； 

​		第二，设置初始MetaSpace的大小和最大大小，因为应用启动时加载类会消耗较多MetaSpace空间，而初始MetaSpace空间大小一般较小，所以JVM会在应用启动的时候执行几次FULLGC为Metaspace扩容，在一开始设置好MetaSpace的初始大小能够加快应用的启动， 同时如果系统中使用了大量的动态代理，要适当的加大Metaspace的空间，防止元数据区溢出。

​		第三，设置合理的升代年龄阈值和大对象的标准， 年龄阈值太小， 会导致老年代中出现生命周期很短的对象，MajorGC过于频繁；太大，则会导致新生代回收效率不高

​		第四，对于除G1GC以外的其他GC， 要设置合理的新生代大小（-Xmn），新生代太小， 会导致新生代频繁GC，浪费性能，如果新生代太大，则一次新生代GC的时间过长，并且老年代会容易满。

​	     对于ParallelGC以后的GC， 要合理设置ParallelGCThreads的大小， 该参数表示进行GC的线程数，要根据cpu的核心数合理设置，一般GC属于计算密集型的操作，因此GC线程数不要设置的过大，避免线程上下文的切换。

​		对于CMSGC， 还要合理设置进行并发GC的阈值（-XX:CMSInitiatingOccupancyFraction）， 该值太大，有可能会导致在并发GC的时候从新生代升级到老年代的对象过多导致老年代不够用，从而引发FULLGC， 该值太小，则GC时间太过频繁， 影响吞吐量。

​		对于G1GC， 要合理设置停顿时间（XX:MaxGCPauseMillis  ）以及调整Region（‐XX:G1HeapRegionSize）的大小，不要手动设置新生代的大小， 手动设置的新生代大小会覆盖停顿时间参数