学习笔记



### 常见问题：

**1、项目中为什么要使用消息中间件？**

比较典型的“生产者消费者模式”，可以跨平台、支持异构系统，通常借助消息中间件来完成。
优点：系统间解耦，并具有一定的可恢复性，支持异构系统，下游通常可并发执行，系统具备弹性。服务解耦、流量削峰填谷等
缺点：消息中间件存在一些瓶颈和一致性问题，对于开发来讲不直观且不易调试，有额外成本。
使用异步消息模式需要注意的问题：

1. 哪些业务需要同步处理，哪些业务可以异步处理？
2. 如何保证消息的安全？消息是否会丢失，是否会重复？
3. 请求的延迟如何能够减少？
4. 消息接收的顺序是否会影响到业务流程的正常执行？
5. 消息处理失败后是否需要重发？如果重发如何保证幂等性？

2、项目中为什么使用RocketMQ而不是RabbitMQ？
3、系统TPS有多少？引入消息中间件之后，系统一定不会被撑爆了吗？
4、消息中间件中出现大量消息堆积，会产生什么后果？
5、如何发现出现了大量消息的堆积？采取了哪些应急措施？问题产生的根源是什么？如何避免





### RabbitMQ相关：

rabbit_variable_quere.erl中定义了RabbitMQ队列的4种状态， 当前是什么状态， 取决于内存的压力 

alpha：索引和内容都存内存，耗内存，不耗cpu

beta：索引存内存， 消息存磁盘

gama：索引存内存和磁盘，消息内容存磁盘

delta：消息索引和内容都放磁盘，消耗更多cpu/io



rabbitmq默认持久化消息的存储目录：

​	/var/lib/rabbitmq/mnesia

rabbitmq默认的配置文件：

​	/var/lib/rabbitmq/rabbitmq.conf    默认没有，需要手动创建

rabbitmqctl help 查看该命令的用法

rabbitmqctl list_channels 查看channel的信息



TCP和Channel的关系

​	

basicPublish： 

​	mandatory参数的含义：当exchange通过routingkey没有找到对应的queue时， 是将消息丢弃呢？还是将消息退还给生产者？？根据mandatory参数进行控制， 设置为false， 则丢掉； 设置成true， 则返回给生产者。

​	immediate参数的含义（该参数在server端已经废弃）：当exchange通过routingkey找到对应的queue，如果该队列上有消费者在监听着队列， 那么会立即将消息发送给消费者， 但是当队列上没有消费者在监听队列时， 该参数如果设置的ture， 则将消息返回给生产者。



RabbitMQ的限流

​	Qos： 当channel中未被确认的消息达到一定的阈值后， broker不再向消费端无脑推消息，而是消费端确认一条， 再推送一条，直到Channel中的消息降到阈值以下。这种限流的本质， 是为了应对峰值流量压垮消费者，采用将生产者的请求，缓冲到Broker中， 然后消费者再按照自己消费的能力进行处理，适用于生产者的流量不稳定，可能瞬时流量会超过消费者的处理能力， 但平均流量和消费者的处理能力相差不多的场景。要注意Broker缓冲消息的能力要超过生产者发送消息的速度。

​	通过配置进行限流： 防止Broker积压过多的消息， 比如当内存使用率，磁盘使用率超过一定数量， 则阻塞生产者，直到消费者处理完毕积压的消息之后再说。这种限流策略的本质， 也是一种服务降级。这种适用于应对突发的，不可预测的流量冲击，对Broker和消费端进行保护， 避免生产者的流量将Broker和消费端冲垮或者导致Broker中积压的消息过多。

除了限流， 还要从生产者，消费端两个层面进行优化， 比如加入生产者端的限流以及服务降级， 避免生产端发送太多消息到Broker中；比如增加消费端的节点，增强消费端的消费处理能力， 或者增加消费端消费消息的线程数，增强并行处理能力，进一步利用服务器资源， 不过要注意， 一是增加线程数，所有线程处理的逻辑都必须是一样的， 因为消息会随机被线程池中的线程所消费， 二是线程数不能越多越好， 要根据服务器的情况， 业务的复杂度， 以及服务器中同时在跑的应用数量， 再进行压测之后确定。



消息可靠性保障：

​	1、消息传输保障

​	2、限流、应急手段

​	3、业务层面的一些容错、补偿、异常重试等手段。



消息可靠性传输：

​	最多一次：消息可能会丢失， 但是绝对不会重复

​	最少一次：消息可能会重复， 但是绝对不会丢失

​	恰好一次：每条消息肯定会被传输一次且仅传输一次

RabbitMQ支持其中的最多一次和最少一次。恰好一次是不能保障的。



实际业务中， 如果需要最少一次， 需要在消费端做好消费者幂等性的判断， 从业务上保证消息不会被重复消费。最多一次则比较危险， 消息可能会因为各种情况 而发生丢失。



TTL机制

​	使用场景： 订单的超时时间处理

​	Rabbit能够从消息和队列两个维度设置TTL时间。

​	TTL时间的设置： 

​		1、通过原生API设置

​		2、通过命令行设置

​		3、通过Spring boot中设置

RabbitMQ的集群配置

​	1、一主多备， 兔子窝模式， 存在的问题是浪费资源

​	2、铲子模式，通过级联队列和交换器的方式， 将消息异步发送到另外服务器上的消息队列中做备份

​	3、Cluster方式： 元数据（交换器、绑定关系、队列等信息）集群共享， 队列分片，即元数据可以实现高可用， 但是队列中的不能实现高可用， 如果一台机器宕机， 则必须等该机器重启之后才能继续消费消息

​	生产方案： Cluster + 镜像队列 + 负载均衡（HaProxy、Nginx等） + KeepAlived

​		用多台RabbitMQ节点做集群，形成一个Cluster， 共享元数据

​		根据需求配置镜像队列， 确保队列中的消息有多个副本， 当master队列所在的服务器宕机， 可以从slave队列中选举一个做为master队列继续提供服务。要主义，镜像队列中所有的入队列和消费消息的操作， 都是由master完成的，因此不存在负载均衡的概念。

​		可以用HaProxy作为VIP，屏蔽集群的信息，统一对外暴露端口，由客户端进行连接，再由HaProxy将请求发送到具体的RabbitMQ中

​		为了防止HaProxy发生单点故障， 可以配置两台HaProxy， 然后用KeepAlived做高可用（**是否可以直接用KeepAlived做VIP和高可用呢？？？？**）

