**第七课第一题**

​	题目：把示例代码，运行一遍，思考课上相关的问题。

**问题一：什么是锁？**

​	锁的本质就是共享资源，获得锁实质就是获得了共享资源。JDK中的锁的实现，不论是synchronized，lock，还是读写锁、StampedLock，其底层都是管程模型的一种实现。

![image-20210204173106620](C:\Users\xiaowenhou\AppData\Roaming\Typora\typora-user-images\image-20210204173106620.png)

​													图片来自于王宝令的Java并发编程实战中的管程小节

​	管程是一种实现线程之间互斥的模型， 有几个要素，一是共享变量， 二是体哦阿健变量， 三是入口等待队列， 四是条件变量等待队列，管程中条件变量和条件等待队列可以有多个。

​	synchronized是管程的特殊实现， 其条件变量和条件等待队列只有一个。

​	当多个线程执行syncharonized修饰的代码块或者方法时， 多个线程都进入入口等待队列， 其中某个线程获取到共享变量（即锁）后，该线程可以继续执行， 其余线程则继续等待在入口等待队列中。获得共享变量的线程执行完毕， 退出synchronized修饰的代码块或者方法，入口等待队列中的线程就会再选择一个进入进行执行。

​	当获得共享变量的线程调用wait之后， 该线程会释放持有的共享变量， 进入条件变量等待队列中，此时入口等待队列中线程就有一个能够进入管程获取到共享变量继续执行， 获得共享变量的线程调用notify方法时， 会从条件变量等待队列中随机选择一个唤醒， 被唤醒的线程进入入口等待队列， 拥有获取共享变量的机会； 获得共享变量的线程调用notifyAll方法时， 会将条件变量等待队列中的所有线程唤醒并且都进入入口等待队列竞争共享变量。

​	JUC包下的AQS就是管程的一种实现， 使用CAS保证了一些操作的原子性， 内部定义了一个state， 该变量就是共享变量，然后定义了一系列的API和子类，我们平时使用的这些线程同步工具以及ReentrantLock，ReadWriteLock都是对这些API的组合调用，如果有需要，我们甚至可以自己通过调用AQS的API实现一个锁。

​	比如Reentrant，是可重入的，并且可以在创建的时候指定是否为公平锁，其实可重入的意思就是初始state的值为0， 每当持有该变量的线程再一次进入，则state加1， 该线程释放锁， 则state减1， 当state等于0的时候就其他等待的线程就可以继续竞争锁；如果设置为公平锁， 则从入口等待队列中按照顺序进入，如果是非公平锁， 则随机一个线程进入；由于Lock中可以有多个条件变量和条件等待队列，因此一个Lock中可以创建出多个condition，不满足条件的线程都等待在相应的队列上。

​	再比如Semphore，创建时要指定许可的值， 即初始化state的值，代表该共享变量可以被多个线程同时访问，并且每进入一个线程， 许可就少一个， 当许可为0的时候， 剩余线程都只能在入口等待队列中等待，访问的线程执行结束后，释放许可，入口等待队列中的线程才能继续获取许可进入。

**问题二：无锁和锁都能实现互斥，到底是无锁实现好还是加锁实现好，什么情况下用无锁实现，什么情况下用加锁实现？**

​	    synchronized本质是悲观锁， 即会认为有多个线程同时竞争， 一上来就必须获取锁；CAS这种保证原子性的操作， 是一种乐观锁，线程不会被挂起，更新共享变量时先获取变量的当前值， 然后去比较，比较如果发现变量的值还是原来的值，说明没有线程修改，自己可以直接修改，如果发现有修改，则会自旋空转一会儿再尝试，直到成功为止。

​	    根据两种实现的原理， 可以看出来当并发冲突比较少的时候， 使用乐观锁要优于使用悲观锁， 因为每次上锁都有额外的开销，在并发冲突较少的情况下， 大部分的锁没有被用到，白白产生开销；而使用乐观锁，大部分的操作都能够一次完成， 只有少量的线程存在竞争， 因此性能更好。

​	    但是当并发冲突比较多的时候， 使用乐观锁的性能就可能不如悲观锁， 因为大量线程存在竞争， 使用乐观锁，同一时间可能有多个线程都必须要进行自旋，自旋本质就是cpu空转，什么也没干， 浪费性能； 而使用悲观锁， 每次线程获得的锁都有意义，其他没有获得锁的状态被挂起，cpu还可以做其他的工作，因此性能更好。